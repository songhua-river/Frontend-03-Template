## HTML PARSE

#### 第一步
+ 为了方便管理,我们把parser单独拆到文件中
+ parser接受HTML文本作为参数，返回值一颗DOM树

#### 第二步
+ 用有限状态机来实现HTML的分析
+ 在HTML标准中，已经规定了HTML的状态

#### 第三步
+ 有三种标签需要处理，开始标签，结束标签，自封闭标签
+ 暂时忽略属性处理

#### 第四步
+ 加入业务罗技
+ 在标签结束的时候提交token

#### 第五步
+ 属性的状态比较多，常见为单引号，双引号，无引号三种
+ 处理方式和标签类似
+ 属性结束时，把属性添加到标签的token上

#### 第六步
+ 使用栈来管理DOM树
+ 遇到开始标签入栈，结束标签出栈
+ 子封闭标签可是看作时入栈后立即出栈
+ 任何元素的父元素是它入栈前的栈顶

#### 第七步
+ 文本节点不需要入栈操作，和子封闭标签类似
+ 多个文本节点标签需要合并

#### 第八步
+ 文本节点不需要入栈操作，和子封闭标签类似
+ 多个文本节点标签需要合并


## CSS PARSE

#### 第一步
+ 遇到style标签时，把css规则保存起来
+ 确认ast的结构

#### 第二步
+ 创建一个元素后立即计算css
+ 理论上当我们分析一个元素时，所有的css规则已经收集完毕
+ 在真实的浏览器中，可能遇到写在body的style标签，需要重新计算css的情况

#### 第三步
+ css匹配规则必须匹配到所有父元素才能知道是否匹配
+ 通过revser处理匹配规则顺序

#### 第四步
+ 选择器也需要从内向外的排列
+ 复杂选择器拆成单个元素的选择器，用循环匹配到父元素队列

#### 第五步
+ 根据选择器的类型和元素属性，计算是否与当前元素匹配

#### 第六步
+ 一旦选择匹配就应用到元素上，形成computedStyle

#### 第七步
+ css规则辊距specificity和后来的优先规则覆盖、
+ specificity是个四元组，月左边权重越高
+ 一个css规则的specificity根据包含的简单选择器相加而成
